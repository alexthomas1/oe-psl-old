// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hello.proto

#ifndef PROTOBUF_INCLUDED_hello_2eproto
#define PROTOBUF_INCLUDED_hello_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "capsule.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_hello_2eproto 

namespace protobuf_hello_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_hello_2eproto
namespace hello_world {
class ActorParam;
class ActorParamDefaultTypeInternal;
extern ActorParamDefaultTypeInternal _ActorParam_default_instance_;
class CoordinatorParam;
class CoordinatorParamDefaultTypeInternal;
extern CoordinatorParamDefaultTypeInternal _CoordinatorParam_default_instance_;
class CryptoParam;
class CryptoParamDefaultTypeInternal;
extern CryptoParamDefaultTypeInternal _CryptoParam_default_instance_;
class EnclaveResponder;
class EnclaveResponderDefaultTypeInternal;
extern EnclaveResponderDefaultTypeInternal _EnclaveResponder_default_instance_;
class HelloInput;
class HelloInputDefaultTypeInternal;
extern HelloInputDefaultTypeInternal _HelloInput_default_instance_;
class HelloOutput;
class HelloOutputDefaultTypeInternal;
extern HelloOutputDefaultTypeInternal _HelloOutput_default_instance_;
class HotMsg;
class HotMsgDefaultTypeInternal;
extern HotMsgDefaultTypeInternal _HotMsg_default_instance_;
class KVS_Server_Config;
class KVS_Server_ConfigDefaultTypeInternal;
extern KVS_Server_ConfigDefaultTypeInternal _KVS_Server_Config_default_instance_;
class MP_Lambda_Input;
class MP_Lambda_InputDefaultTypeInternal;
extern MP_Lambda_InputDefaultTypeInternal _MP_Lambda_Input_default_instance_;
}  // namespace hello_world
namespace google {
namespace protobuf {
template<> ::hello_world::ActorParam* Arena::CreateMaybeMessage<::hello_world::ActorParam>(Arena*);
template<> ::hello_world::CoordinatorParam* Arena::CreateMaybeMessage<::hello_world::CoordinatorParam>(Arena*);
template<> ::hello_world::CryptoParam* Arena::CreateMaybeMessage<::hello_world::CryptoParam>(Arena*);
template<> ::hello_world::EnclaveResponder* Arena::CreateMaybeMessage<::hello_world::EnclaveResponder>(Arena*);
template<> ::hello_world::HelloInput* Arena::CreateMaybeMessage<::hello_world::HelloInput>(Arena*);
template<> ::hello_world::HelloOutput* Arena::CreateMaybeMessage<::hello_world::HelloOutput>(Arena*);
template<> ::hello_world::HotMsg* Arena::CreateMaybeMessage<::hello_world::HotMsg>(Arena*);
template<> ::hello_world::KVS_Server_Config* Arena::CreateMaybeMessage<::hello_world::KVS_Server_Config>(Arena*);
template<> ::hello_world::MP_Lambda_Input* Arena::CreateMaybeMessage<::hello_world::MP_Lambda_Input>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hello_world {

// ===================================================================

class HelloInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.HelloInput) */ {
 public:
  HelloInput();
  virtual ~HelloInput();

  HelloInput(const HelloInput& from);

  inline HelloInput& operator=(const HelloInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloInput(HelloInput&& from) noexcept
    : HelloInput() {
    *this = ::std::move(from);
  }

  inline HelloInput& operator=(HelloInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloInput* internal_default_instance() {
    return reinterpret_cast<const HelloInput*>(
               &_HelloInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(HelloInput* other);
  friend void swap(HelloInput& a, HelloInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloInput* New() const final {
    return CreateMaybeMessage<HelloInput>(NULL);
  }

  HelloInput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HelloInput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HelloInput& from);
  void MergeFrom(const HelloInput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string to_greet = 1;
  bool has_to_greet() const;
  void clear_to_greet();
  static const int kToGreetFieldNumber = 1;
  const ::std::string& to_greet() const;
  void set_to_greet(const ::std::string& value);
  #if LANG_CXX11
  void set_to_greet(::std::string&& value);
  #endif
  void set_to_greet(const char* value);
  void set_to_greet(const char* value, size_t size);
  ::std::string* mutable_to_greet();
  ::std::string* release_to_greet();
  void set_allocated_to_greet(::std::string* to_greet);

  // @@protoc_insertion_point(class_scope:hello_world.HelloInput)
 private:
  void set_has_to_greet();
  void clear_has_to_greet();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr to_greet_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HelloOutput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.HelloOutput) */ {
 public:
  HelloOutput();
  virtual ~HelloOutput();

  HelloOutput(const HelloOutput& from);

  inline HelloOutput& operator=(const HelloOutput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloOutput(HelloOutput&& from) noexcept
    : HelloOutput() {
    *this = ::std::move(from);
  }

  inline HelloOutput& operator=(HelloOutput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HelloOutput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloOutput* internal_default_instance() {
    return reinterpret_cast<const HelloOutput*>(
               &_HelloOutput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(HelloOutput* other);
  friend void swap(HelloOutput& a, HelloOutput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloOutput* New() const final {
    return CreateMaybeMessage<HelloOutput>(NULL);
  }

  HelloOutput* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HelloOutput>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HelloOutput& from);
  void MergeFrom(const HelloOutput& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloOutput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string greeting_message = 1;
  bool has_greeting_message() const;
  void clear_greeting_message();
  static const int kGreetingMessageFieldNumber = 1;
  const ::std::string& greeting_message() const;
  void set_greeting_message(const ::std::string& value);
  #if LANG_CXX11
  void set_greeting_message(::std::string&& value);
  #endif
  void set_greeting_message(const char* value);
  void set_greeting_message(const char* value, size_t size);
  ::std::string* mutable_greeting_message();
  ::std::string* release_greeting_message();
  void set_allocated_greeting_message(::std::string* greeting_message);

  // @@protoc_insertion_point(class_scope:hello_world.HelloOutput)
 private:
  void set_has_greeting_message();
  void clear_has_greeting_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr greeting_message_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EnclaveResponder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.EnclaveResponder) */ {
 public:
  EnclaveResponder();
  virtual ~EnclaveResponder();

  EnclaveResponder(const EnclaveResponder& from);

  inline EnclaveResponder& operator=(const EnclaveResponder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnclaveResponder(EnclaveResponder&& from) noexcept
    : EnclaveResponder() {
    *this = ::std::move(from);
  }

  inline EnclaveResponder& operator=(EnclaveResponder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnclaveResponder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnclaveResponder* internal_default_instance() {
    return reinterpret_cast<const EnclaveResponder*>(
               &_EnclaveResponder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(EnclaveResponder* other);
  friend void swap(EnclaveResponder& a, EnclaveResponder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnclaveResponder* New() const final {
    return CreateMaybeMessage<EnclaveResponder>(NULL);
  }

  EnclaveResponder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EnclaveResponder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EnclaveResponder& from);
  void MergeFrom(const EnclaveResponder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnclaveResponder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 responder = 1;
  bool has_responder() const;
  void clear_responder();
  static const int kResponderFieldNumber = 1;
  ::google::protobuf::int64 responder() const;
  void set_responder(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hello_world.EnclaveResponder)
 private:
  void set_has_responder();
  void clear_has_responder();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 responder_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HotMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.HotMsg) */ {
 public:
  HotMsg();
  virtual ~HotMsg();

  HotMsg(const HotMsg& from);

  inline HotMsg& operator=(const HotMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HotMsg(HotMsg&& from) noexcept
    : HotMsg() {
    *this = ::std::move(from);
  }

  inline HotMsg& operator=(HotMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HotMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HotMsg* internal_default_instance() {
    return reinterpret_cast<const HotMsg*>(
               &_HotMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(HotMsg* other);
  friend void swap(HotMsg& a, HotMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HotMsg* New() const final {
    return CreateMaybeMessage<HotMsg>(NULL);
  }

  HotMsg* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HotMsg>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HotMsg& from);
  void MergeFrom(const HotMsg& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HotMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string enclave_id = 2;
  bool has_enclave_id() const;
  void clear_enclave_id();
  static const int kEnclaveIdFieldNumber = 2;
  const ::std::string& enclave_id() const;
  void set_enclave_id(const ::std::string& value);
  #if LANG_CXX11
  void set_enclave_id(::std::string&& value);
  #endif
  void set_enclave_id(const char* value);
  void set_enclave_id(const char* value, size_t size);
  ::std::string* mutable_enclave_id();
  ::std::string* release_enclave_id();
  void set_allocated_enclave_id(::std::string* enclave_id);

  // optional int64 buffer = 1;
  bool has_buffer() const;
  void clear_buffer();
  static const int kBufferFieldNumber = 1;
  ::google::protobuf::int64 buffer() const;
  void set_buffer(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hello_world.HotMsg)
 private:
  void set_has_buffer();
  void clear_has_buffer();
  void set_has_enclave_id();
  void clear_has_enclave_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr enclave_id_;
  ::google::protobuf::int64 buffer_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KVS_Server_Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.KVS_Server_Config) */ {
 public:
  KVS_Server_Config();
  virtual ~KVS_Server_Config();

  KVS_Server_Config(const KVS_Server_Config& from);

  inline KVS_Server_Config& operator=(const KVS_Server_Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KVS_Server_Config(KVS_Server_Config&& from) noexcept
    : KVS_Server_Config() {
    *this = ::std::move(from);
  }

  inline KVS_Server_Config& operator=(KVS_Server_Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KVS_Server_Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KVS_Server_Config* internal_default_instance() {
    return reinterpret_cast<const KVS_Server_Config*>(
               &_KVS_Server_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(KVS_Server_Config* other);
  friend void swap(KVS_Server_Config& a, KVS_Server_Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KVS_Server_Config* New() const final {
    return CreateMaybeMessage<KVS_Server_Config>(NULL);
  }

  KVS_Server_Config* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KVS_Server_Config>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KVS_Server_Config& from);
  void MergeFrom(const KVS_Server_Config& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KVS_Server_Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string server_address = 1;
  bool has_server_address() const;
  void clear_server_address();
  static const int kServerAddressFieldNumber = 1;
  const ::std::string& server_address() const;
  void set_server_address(const ::std::string& value);
  #if LANG_CXX11
  void set_server_address(::std::string&& value);
  #endif
  void set_server_address(const char* value);
  void set_server_address(const char* value, size_t size);
  ::std::string* mutable_server_address();
  ::std::string* release_server_address();
  void set_allocated_server_address(::std::string* server_address);

  // optional int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:hello_world.KVS_Server_Config)
 private:
  void set_has_server_address();
  void clear_has_server_address();
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr server_address_;
  ::google::protobuf::int32 port_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MP_Lambda_Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.MP_Lambda_Input) */ {
 public:
  MP_Lambda_Input();
  virtual ~MP_Lambda_Input();

  MP_Lambda_Input(const MP_Lambda_Input& from);

  inline MP_Lambda_Input& operator=(const MP_Lambda_Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MP_Lambda_Input(MP_Lambda_Input&& from) noexcept
    : MP_Lambda_Input() {
    *this = ::std::move(from);
  }

  inline MP_Lambda_Input& operator=(MP_Lambda_Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MP_Lambda_Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MP_Lambda_Input* internal_default_instance() {
    return reinterpret_cast<const MP_Lambda_Input*>(
               &_MP_Lambda_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(MP_Lambda_Input* other);
  friend void swap(MP_Lambda_Input& a, MP_Lambda_Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MP_Lambda_Input* New() const final {
    return CreateMaybeMessage<MP_Lambda_Input>(NULL);
  }

  MP_Lambda_Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MP_Lambda_Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MP_Lambda_Input& from);
  void MergeFrom(const MP_Lambda_Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MP_Lambda_Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string coordinator = 1;
  bool has_coordinator() const;
  void clear_coordinator();
  static const int kCoordinatorFieldNumber = 1;
  const ::std::string& coordinator() const;
  void set_coordinator(const ::std::string& value);
  #if LANG_CXX11
  void set_coordinator(::std::string&& value);
  #endif
  void set_coordinator(const char* value);
  void set_coordinator(const char* value, size_t size);
  ::std::string* mutable_coordinator();
  ::std::string* release_coordinator();
  void set_allocated_coordinator(::std::string* coordinator);

  // optional string algorithm = 2;
  bool has_algorithm() const;
  void clear_algorithm();
  static const int kAlgorithmFieldNumber = 2;
  const ::std::string& algorithm() const;
  void set_algorithm(const ::std::string& value);
  #if LANG_CXX11
  void set_algorithm(::std::string&& value);
  #endif
  void set_algorithm(const char* value);
  void set_algorithm(const char* value, size_t size);
  ::std::string* mutable_algorithm();
  ::std::string* release_algorithm();
  void set_allocated_algorithm(::std::string* algorithm);

  // optional string scenario = 3;
  bool has_scenario() const;
  void clear_scenario();
  static const int kScenarioFieldNumber = 3;
  const ::std::string& scenario() const;
  void set_scenario(const ::std::string& value);
  #if LANG_CXX11
  void set_scenario(::std::string&& value);
  #endif
  void set_scenario(const char* value);
  void set_scenario(const char* value, size_t size);
  ::std::string* mutable_scenario();
  ::std::string* release_scenario();
  void set_allocated_scenario(::std::string* scenario);

  // optional string start = 4;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 4;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const char* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // optional string goal = 5;
  bool has_goal() const;
  void clear_goal();
  static const int kGoalFieldNumber = 5;
  const ::std::string& goal() const;
  void set_goal(const ::std::string& value);
  #if LANG_CXX11
  void set_goal(::std::string&& value);
  #endif
  void set_goal(const char* value);
  void set_goal(const char* value, size_t size);
  ::std::string* mutable_goal();
  ::std::string* release_goal();
  void set_allocated_goal(::std::string* goal);

  // optional string min = 6;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 6;
  const ::std::string& min() const;
  void set_min(const ::std::string& value);
  #if LANG_CXX11
  void set_min(::std::string&& value);
  #endif
  void set_min(const char* value);
  void set_min(const char* value, size_t size);
  ::std::string* mutable_min();
  ::std::string* release_min();
  void set_allocated_min(::std::string* min);

  // optional string max = 7;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 7;
  const ::std::string& max() const;
  void set_max(const ::std::string& value);
  #if LANG_CXX11
  void set_max(::std::string&& value);
  #endif
  void set_max(const char* value);
  void set_max(const char* value, size_t size);
  ::std::string* mutable_max();
  ::std::string* release_max();
  void set_allocated_max(::std::string* max);

  // optional string robot = 8;
  bool has_robot() const;
  void clear_robot();
  static const int kRobotFieldNumber = 8;
  const ::std::string& robot() const;
  void set_robot(const ::std::string& value);
  #if LANG_CXX11
  void set_robot(::std::string&& value);
  #endif
  void set_robot(const char* value);
  void set_robot(const char* value, size_t size);
  ::std::string* mutable_robot();
  ::std::string* release_robot();
  void set_allocated_robot(::std::string* robot);

  // optional string time_limit = 9;
  bool has_time_limit() const;
  void clear_time_limit();
  static const int kTimeLimitFieldNumber = 9;
  const ::std::string& time_limit() const;
  void set_time_limit(const ::std::string& value);
  #if LANG_CXX11
  void set_time_limit(::std::string&& value);
  #endif
  void set_time_limit(const char* value);
  void set_time_limit(const char* value, size_t size);
  ::std::string* mutable_time_limit();
  ::std::string* release_time_limit();
  void set_allocated_time_limit(::std::string* time_limit);

  // optional string env = 10;
  bool has_env() const;
  void clear_env();
  static const int kEnvFieldNumber = 10;
  const ::std::string& env() const;
  void set_env(const ::std::string& value);
  #if LANG_CXX11
  void set_env(::std::string&& value);
  #endif
  void set_env(const char* value);
  void set_env(const char* value, size_t size);
  ::std::string* mutable_env();
  ::std::string* release_env();
  void set_allocated_env(::std::string* env);

  // optional string check_resolution = 11;
  bool has_check_resolution() const;
  void clear_check_resolution();
  static const int kCheckResolutionFieldNumber = 11;
  const ::std::string& check_resolution() const;
  void set_check_resolution(const ::std::string& value);
  #if LANG_CXX11
  void set_check_resolution(::std::string&& value);
  #endif
  void set_check_resolution(const char* value);
  void set_check_resolution(const char* value, size_t size);
  ::std::string* mutable_check_resolution();
  ::std::string* release_check_resolution();
  void set_allocated_check_resolution(::std::string* check_resolution);

  // optional string discretization = 12;
  bool has_discretization() const;
  void clear_discretization();
  static const int kDiscretizationFieldNumber = 12;
  const ::std::string& discretization() const;
  void set_discretization(const ::std::string& value);
  #if LANG_CXX11
  void set_discretization(::std::string&& value);
  #endif
  void set_discretization(const char* value);
  void set_discretization(const char* value, size_t size);
  ::std::string* mutable_discretization();
  ::std::string* release_discretization();
  void set_allocated_discretization(::std::string* discretization);

  // optional string is_float = 13;
  bool has_is_float() const;
  void clear_is_float();
  static const int kIsFloatFieldNumber = 13;
  const ::std::string& is_float() const;
  void set_is_float(const ::std::string& value);
  #if LANG_CXX11
  void set_is_float(::std::string&& value);
  #endif
  void set_is_float(const char* value);
  void set_is_float(const char* value, size_t size);
  ::std::string* mutable_is_float();
  ::std::string* release_is_float();
  void set_allocated_is_float(::std::string* is_float);

  // optional string problem_id = 14;
  bool has_problem_id() const;
  void clear_problem_id();
  static const int kProblemIdFieldNumber = 14;
  const ::std::string& problem_id() const;
  void set_problem_id(const ::std::string& value);
  #if LANG_CXX11
  void set_problem_id(::std::string&& value);
  #endif
  void set_problem_id(const char* value);
  void set_problem_id(const char* value, size_t size);
  ::std::string* mutable_problem_id();
  ::std::string* release_problem_id();
  void set_allocated_problem_id(::std::string* problem_id);

  // optional string goal_radius = 15;
  bool has_goal_radius() const;
  void clear_goal_radius();
  static const int kGoalRadiusFieldNumber = 15;
  const ::std::string& goal_radius() const;
  void set_goal_radius(const ::std::string& value);
  #if LANG_CXX11
  void set_goal_radius(::std::string&& value);
  #endif
  void set_goal_radius(const char* value);
  void set_goal_radius(const char* value, size_t size);
  ::std::string* mutable_goal_radius();
  ::std::string* release_goal_radius();
  void set_allocated_goal_radius(::std::string* goal_radius);

  // optional string env_frame = 16;
  bool has_env_frame() const;
  void clear_env_frame();
  static const int kEnvFrameFieldNumber = 16;
  const ::std::string& env_frame() const;
  void set_env_frame(const ::std::string& value);
  #if LANG_CXX11
  void set_env_frame(::std::string&& value);
  #endif
  void set_env_frame(const char* value);
  void set_env_frame(const char* value, size_t size);
  ::std::string* mutable_env_frame();
  ::std::string* release_env_frame();
  void set_allocated_env_frame(::std::string* env_frame);

  // optional string jobs = 17;
  bool has_jobs() const;
  void clear_jobs();
  static const int kJobsFieldNumber = 17;
  const ::std::string& jobs() const;
  void set_jobs(const ::std::string& value);
  #if LANG_CXX11
  void set_jobs(::std::string&& value);
  #endif
  void set_jobs(const char* value);
  void set_jobs(const char* value, size_t size);
  ::std::string* mutable_jobs();
  ::std::string* release_jobs();
  void set_allocated_jobs(::std::string* jobs);

  // optional int64 time_start = 18;
  bool has_time_start() const;
  void clear_time_start();
  static const int kTimeStartFieldNumber = 18;
  ::google::protobuf::int64 time_start() const;
  void set_time_start(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hello_world.MP_Lambda_Input)
 private:
  void set_has_coordinator();
  void clear_has_coordinator();
  void set_has_algorithm();
  void clear_has_algorithm();
  void set_has_scenario();
  void clear_has_scenario();
  void set_has_start();
  void clear_has_start();
  void set_has_goal();
  void clear_has_goal();
  void set_has_min();
  void clear_has_min();
  void set_has_max();
  void clear_has_max();
  void set_has_robot();
  void clear_has_robot();
  void set_has_time_limit();
  void clear_has_time_limit();
  void set_has_env();
  void clear_has_env();
  void set_has_check_resolution();
  void clear_has_check_resolution();
  void set_has_discretization();
  void clear_has_discretization();
  void set_has_is_float();
  void clear_has_is_float();
  void set_has_problem_id();
  void clear_has_problem_id();
  void set_has_goal_radius();
  void clear_has_goal_radius();
  void set_has_env_frame();
  void clear_has_env_frame();
  void set_has_jobs();
  void clear_has_jobs();
  void set_has_time_start();
  void clear_has_time_start();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr coordinator_;
  ::google::protobuf::internal::ArenaStringPtr algorithm_;
  ::google::protobuf::internal::ArenaStringPtr scenario_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::internal::ArenaStringPtr goal_;
  ::google::protobuf::internal::ArenaStringPtr min_;
  ::google::protobuf::internal::ArenaStringPtr max_;
  ::google::protobuf::internal::ArenaStringPtr robot_;
  ::google::protobuf::internal::ArenaStringPtr time_limit_;
  ::google::protobuf::internal::ArenaStringPtr env_;
  ::google::protobuf::internal::ArenaStringPtr check_resolution_;
  ::google::protobuf::internal::ArenaStringPtr discretization_;
  ::google::protobuf::internal::ArenaStringPtr is_float_;
  ::google::protobuf::internal::ArenaStringPtr problem_id_;
  ::google::protobuf::internal::ArenaStringPtr goal_radius_;
  ::google::protobuf::internal::ArenaStringPtr env_frame_;
  ::google::protobuf::internal::ArenaStringPtr jobs_;
  ::google::protobuf::int64 time_start_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CoordinatorParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.CoordinatorParam) */ {
 public:
  CoordinatorParam();
  virtual ~CoordinatorParam();

  CoordinatorParam(const CoordinatorParam& from);

  inline CoordinatorParam& operator=(const CoordinatorParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoordinatorParam(CoordinatorParam&& from) noexcept
    : CoordinatorParam() {
    *this = ::std::move(from);
  }

  inline CoordinatorParam& operator=(CoordinatorParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordinatorParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoordinatorParam* internal_default_instance() {
    return reinterpret_cast<const CoordinatorParam*>(
               &_CoordinatorParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(CoordinatorParam* other);
  friend void swap(CoordinatorParam& a, CoordinatorParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoordinatorParam* New() const final {
    return CreateMaybeMessage<CoordinatorParam>(NULL);
  }

  CoordinatorParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CoordinatorParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CoordinatorParam& from);
  void MergeFrom(const CoordinatorParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinatorParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 circ_buffer = 1;
  bool has_circ_buffer() const;
  void clear_circ_buffer();
  static const int kCircBufferFieldNumber = 1;
  ::google::protobuf::int64 circ_buffer() const;
  void set_circ_buffer(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hello_world.CoordinatorParam)
 private:
  void set_has_circ_buffer();
  void clear_has_circ_buffer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 circ_buffer_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActorParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.ActorParam) */ {
 public:
  ActorParam();
  virtual ~ActorParam();

  ActorParam(const ActorParam& from);

  inline ActorParam& operator=(const ActorParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActorParam(ActorParam&& from) noexcept
    : ActorParam() {
    *this = ::std::move(from);
  }

  inline ActorParam& operator=(ActorParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActorParam* internal_default_instance() {
    return reinterpret_cast<const ActorParam*>(
               &_ActorParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ActorParam* other);
  friend void swap(ActorParam& a, ActorParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActorParam* New() const final {
    return CreateMaybeMessage<ActorParam>(NULL);
  }

  ActorParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActorParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActorParam& from);
  void MergeFrom(const ActorParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActorParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 is_actor = 1;
  bool has_is_actor() const;
  void clear_is_actor();
  static const int kIsActorFieldNumber = 1;
  ::google::protobuf::int64 is_actor() const;
  void set_is_actor(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:hello_world.ActorParam)
 private:
  void set_has_is_actor();
  void clear_has_is_actor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 is_actor_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CryptoParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hello_world.CryptoParam) */ {
 public:
  CryptoParam();
  virtual ~CryptoParam();

  CryptoParam(const CryptoParam& from);

  inline CryptoParam& operator=(const CryptoParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CryptoParam(CryptoParam&& from) noexcept
    : CryptoParam() {
    *this = ::std::move(from);
  }

  inline CryptoParam& operator=(CryptoParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CryptoParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CryptoParam* internal_default_instance() {
    return reinterpret_cast<const CryptoParam*>(
               &_CryptoParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CryptoParam* other);
  friend void swap(CryptoParam& a, CryptoParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CryptoParam* New() const final {
    return CreateMaybeMessage<CryptoParam>(NULL);
  }

  CryptoParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CryptoParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CryptoParam& from);
  void MergeFrom(const CryptoParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CryptoParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:hello_world.CryptoParam)
 private:
  void set_has_key();
  void clear_has_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  friend struct ::protobuf_hello_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloInput

// optional string to_greet = 1;
inline bool HelloInput::has_to_greet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloInput::set_has_to_greet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloInput::clear_has_to_greet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloInput::clear_to_greet() {
  to_greet_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to_greet();
}
inline const ::std::string& HelloInput::to_greet() const {
  // @@protoc_insertion_point(field_get:hello_world.HelloInput.to_greet)
  return to_greet_.GetNoArena();
}
inline void HelloInput::set_to_greet(const ::std::string& value) {
  set_has_to_greet();
  to_greet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.HelloInput.to_greet)
}
#if LANG_CXX11
inline void HelloInput::set_to_greet(::std::string&& value) {
  set_has_to_greet();
  to_greet_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.HelloInput.to_greet)
}
#endif
inline void HelloInput::set_to_greet(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to_greet();
  to_greet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.HelloInput.to_greet)
}
inline void HelloInput::set_to_greet(const char* value, size_t size) {
  set_has_to_greet();
  to_greet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.HelloInput.to_greet)
}
inline ::std::string* HelloInput::mutable_to_greet() {
  set_has_to_greet();
  // @@protoc_insertion_point(field_mutable:hello_world.HelloInput.to_greet)
  return to_greet_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloInput::release_to_greet() {
  // @@protoc_insertion_point(field_release:hello_world.HelloInput.to_greet)
  if (!has_to_greet()) {
    return NULL;
  }
  clear_has_to_greet();
  return to_greet_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloInput::set_allocated_to_greet(::std::string* to_greet) {
  if (to_greet != NULL) {
    set_has_to_greet();
  } else {
    clear_has_to_greet();
  }
  to_greet_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_greet);
  // @@protoc_insertion_point(field_set_allocated:hello_world.HelloInput.to_greet)
}

// -------------------------------------------------------------------

// HelloOutput

// optional string greeting_message = 1;
inline bool HelloOutput::has_greeting_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HelloOutput::set_has_greeting_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HelloOutput::clear_has_greeting_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HelloOutput::clear_greeting_message() {
  greeting_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_greeting_message();
}
inline const ::std::string& HelloOutput::greeting_message() const {
  // @@protoc_insertion_point(field_get:hello_world.HelloOutput.greeting_message)
  return greeting_message_.GetNoArena();
}
inline void HelloOutput::set_greeting_message(const ::std::string& value) {
  set_has_greeting_message();
  greeting_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.HelloOutput.greeting_message)
}
#if LANG_CXX11
inline void HelloOutput::set_greeting_message(::std::string&& value) {
  set_has_greeting_message();
  greeting_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.HelloOutput.greeting_message)
}
#endif
inline void HelloOutput::set_greeting_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_greeting_message();
  greeting_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.HelloOutput.greeting_message)
}
inline void HelloOutput::set_greeting_message(const char* value, size_t size) {
  set_has_greeting_message();
  greeting_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.HelloOutput.greeting_message)
}
inline ::std::string* HelloOutput::mutable_greeting_message() {
  set_has_greeting_message();
  // @@protoc_insertion_point(field_mutable:hello_world.HelloOutput.greeting_message)
  return greeting_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloOutput::release_greeting_message() {
  // @@protoc_insertion_point(field_release:hello_world.HelloOutput.greeting_message)
  if (!has_greeting_message()) {
    return NULL;
  }
  clear_has_greeting_message();
  return greeting_message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloOutput::set_allocated_greeting_message(::std::string* greeting_message) {
  if (greeting_message != NULL) {
    set_has_greeting_message();
  } else {
    clear_has_greeting_message();
  }
  greeting_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), greeting_message);
  // @@protoc_insertion_point(field_set_allocated:hello_world.HelloOutput.greeting_message)
}

// -------------------------------------------------------------------

// EnclaveResponder

// optional int64 responder = 1;
inline bool EnclaveResponder::has_responder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnclaveResponder::set_has_responder() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnclaveResponder::clear_has_responder() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnclaveResponder::clear_responder() {
  responder_ = GOOGLE_LONGLONG(0);
  clear_has_responder();
}
inline ::google::protobuf::int64 EnclaveResponder::responder() const {
  // @@protoc_insertion_point(field_get:hello_world.EnclaveResponder.responder)
  return responder_;
}
inline void EnclaveResponder::set_responder(::google::protobuf::int64 value) {
  set_has_responder();
  responder_ = value;
  // @@protoc_insertion_point(field_set:hello_world.EnclaveResponder.responder)
}

// -------------------------------------------------------------------

// HotMsg

// optional int64 buffer = 1;
inline bool HotMsg::has_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HotMsg::set_has_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HotMsg::clear_has_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HotMsg::clear_buffer() {
  buffer_ = GOOGLE_LONGLONG(0);
  clear_has_buffer();
}
inline ::google::protobuf::int64 HotMsg::buffer() const {
  // @@protoc_insertion_point(field_get:hello_world.HotMsg.buffer)
  return buffer_;
}
inline void HotMsg::set_buffer(::google::protobuf::int64 value) {
  set_has_buffer();
  buffer_ = value;
  // @@protoc_insertion_point(field_set:hello_world.HotMsg.buffer)
}

// optional string enclave_id = 2;
inline bool HotMsg::has_enclave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HotMsg::set_has_enclave_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HotMsg::clear_has_enclave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HotMsg::clear_enclave_id() {
  enclave_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enclave_id();
}
inline const ::std::string& HotMsg::enclave_id() const {
  // @@protoc_insertion_point(field_get:hello_world.HotMsg.enclave_id)
  return enclave_id_.GetNoArena();
}
inline void HotMsg::set_enclave_id(const ::std::string& value) {
  set_has_enclave_id();
  enclave_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.HotMsg.enclave_id)
}
#if LANG_CXX11
inline void HotMsg::set_enclave_id(::std::string&& value) {
  set_has_enclave_id();
  enclave_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.HotMsg.enclave_id)
}
#endif
inline void HotMsg::set_enclave_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_enclave_id();
  enclave_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.HotMsg.enclave_id)
}
inline void HotMsg::set_enclave_id(const char* value, size_t size) {
  set_has_enclave_id();
  enclave_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.HotMsg.enclave_id)
}
inline ::std::string* HotMsg::mutable_enclave_id() {
  set_has_enclave_id();
  // @@protoc_insertion_point(field_mutable:hello_world.HotMsg.enclave_id)
  return enclave_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HotMsg::release_enclave_id() {
  // @@protoc_insertion_point(field_release:hello_world.HotMsg.enclave_id)
  if (!has_enclave_id()) {
    return NULL;
  }
  clear_has_enclave_id();
  return enclave_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HotMsg::set_allocated_enclave_id(::std::string* enclave_id) {
  if (enclave_id != NULL) {
    set_has_enclave_id();
  } else {
    clear_has_enclave_id();
  }
  enclave_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enclave_id);
  // @@protoc_insertion_point(field_set_allocated:hello_world.HotMsg.enclave_id)
}

// -------------------------------------------------------------------

// KVS_Server_Config

// optional string server_address = 1;
inline bool KVS_Server_Config::has_server_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KVS_Server_Config::set_has_server_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KVS_Server_Config::clear_has_server_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KVS_Server_Config::clear_server_address() {
  server_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_address();
}
inline const ::std::string& KVS_Server_Config::server_address() const {
  // @@protoc_insertion_point(field_get:hello_world.KVS_Server_Config.server_address)
  return server_address_.GetNoArena();
}
inline void KVS_Server_Config::set_server_address(const ::std::string& value) {
  set_has_server_address();
  server_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.KVS_Server_Config.server_address)
}
#if LANG_CXX11
inline void KVS_Server_Config::set_server_address(::std::string&& value) {
  set_has_server_address();
  server_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.KVS_Server_Config.server_address)
}
#endif
inline void KVS_Server_Config::set_server_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_server_address();
  server_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.KVS_Server_Config.server_address)
}
inline void KVS_Server_Config::set_server_address(const char* value, size_t size) {
  set_has_server_address();
  server_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.KVS_Server_Config.server_address)
}
inline ::std::string* KVS_Server_Config::mutable_server_address() {
  set_has_server_address();
  // @@protoc_insertion_point(field_mutable:hello_world.KVS_Server_Config.server_address)
  return server_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KVS_Server_Config::release_server_address() {
  // @@protoc_insertion_point(field_release:hello_world.KVS_Server_Config.server_address)
  if (!has_server_address()) {
    return NULL;
  }
  clear_has_server_address();
  return server_address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KVS_Server_Config::set_allocated_server_address(::std::string* server_address) {
  if (server_address != NULL) {
    set_has_server_address();
  } else {
    clear_has_server_address();
  }
  server_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_address);
  // @@protoc_insertion_point(field_set_allocated:hello_world.KVS_Server_Config.server_address)
}

// optional int32 port = 2;
inline bool KVS_Server_Config::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KVS_Server_Config::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KVS_Server_Config::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KVS_Server_Config::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 KVS_Server_Config::port() const {
  // @@protoc_insertion_point(field_get:hello_world.KVS_Server_Config.port)
  return port_;
}
inline void KVS_Server_Config::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:hello_world.KVS_Server_Config.port)
}

// -------------------------------------------------------------------

// MP_Lambda_Input

// optional string coordinator = 1;
inline bool MP_Lambda_Input::has_coordinator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MP_Lambda_Input::set_has_coordinator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MP_Lambda_Input::clear_has_coordinator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MP_Lambda_Input::clear_coordinator() {
  coordinator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coordinator();
}
inline const ::std::string& MP_Lambda_Input::coordinator() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.coordinator)
  return coordinator_.GetNoArena();
}
inline void MP_Lambda_Input::set_coordinator(const ::std::string& value) {
  set_has_coordinator();
  coordinator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.coordinator)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_coordinator(::std::string&& value) {
  set_has_coordinator();
  coordinator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.coordinator)
}
#endif
inline void MP_Lambda_Input::set_coordinator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coordinator();
  coordinator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.coordinator)
}
inline void MP_Lambda_Input::set_coordinator(const char* value, size_t size) {
  set_has_coordinator();
  coordinator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.coordinator)
}
inline ::std::string* MP_Lambda_Input::mutable_coordinator() {
  set_has_coordinator();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.coordinator)
  return coordinator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_coordinator() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.coordinator)
  if (!has_coordinator()) {
    return NULL;
  }
  clear_has_coordinator();
  return coordinator_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_coordinator(::std::string* coordinator) {
  if (coordinator != NULL) {
    set_has_coordinator();
  } else {
    clear_has_coordinator();
  }
  coordinator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coordinator);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.coordinator)
}

// optional string algorithm = 2;
inline bool MP_Lambda_Input::has_algorithm() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MP_Lambda_Input::set_has_algorithm() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MP_Lambda_Input::clear_has_algorithm() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MP_Lambda_Input::clear_algorithm() {
  algorithm_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_algorithm();
}
inline const ::std::string& MP_Lambda_Input::algorithm() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.algorithm)
  return algorithm_.GetNoArena();
}
inline void MP_Lambda_Input::set_algorithm(const ::std::string& value) {
  set_has_algorithm();
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.algorithm)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_algorithm(::std::string&& value) {
  set_has_algorithm();
  algorithm_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.algorithm)
}
#endif
inline void MP_Lambda_Input::set_algorithm(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_algorithm();
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.algorithm)
}
inline void MP_Lambda_Input::set_algorithm(const char* value, size_t size) {
  set_has_algorithm();
  algorithm_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.algorithm)
}
inline ::std::string* MP_Lambda_Input::mutable_algorithm() {
  set_has_algorithm();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.algorithm)
  return algorithm_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_algorithm() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.algorithm)
  if (!has_algorithm()) {
    return NULL;
  }
  clear_has_algorithm();
  return algorithm_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_algorithm(::std::string* algorithm) {
  if (algorithm != NULL) {
    set_has_algorithm();
  } else {
    clear_has_algorithm();
  }
  algorithm_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), algorithm);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.algorithm)
}

// optional string scenario = 3;
inline bool MP_Lambda_Input::has_scenario() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MP_Lambda_Input::set_has_scenario() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MP_Lambda_Input::clear_has_scenario() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MP_Lambda_Input::clear_scenario() {
  scenario_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scenario();
}
inline const ::std::string& MP_Lambda_Input::scenario() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.scenario)
  return scenario_.GetNoArena();
}
inline void MP_Lambda_Input::set_scenario(const ::std::string& value) {
  set_has_scenario();
  scenario_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.scenario)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_scenario(::std::string&& value) {
  set_has_scenario();
  scenario_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.scenario)
}
#endif
inline void MP_Lambda_Input::set_scenario(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_scenario();
  scenario_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.scenario)
}
inline void MP_Lambda_Input::set_scenario(const char* value, size_t size) {
  set_has_scenario();
  scenario_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.scenario)
}
inline ::std::string* MP_Lambda_Input::mutable_scenario() {
  set_has_scenario();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.scenario)
  return scenario_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_scenario() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.scenario)
  if (!has_scenario()) {
    return NULL;
  }
  clear_has_scenario();
  return scenario_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_scenario(::std::string* scenario) {
  if (scenario != NULL) {
    set_has_scenario();
  } else {
    clear_has_scenario();
  }
  scenario_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scenario);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.scenario)
}

// optional string start = 4;
inline bool MP_Lambda_Input::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MP_Lambda_Input::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MP_Lambda_Input::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MP_Lambda_Input::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_start();
}
inline const ::std::string& MP_Lambda_Input::start() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.start)
  return start_.GetNoArena();
}
inline void MP_Lambda_Input::set_start(const ::std::string& value) {
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.start)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_start(::std::string&& value) {
  set_has_start();
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.start)
}
#endif
inline void MP_Lambda_Input::set_start(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.start)
}
inline void MP_Lambda_Input::set_start(const char* value, size_t size) {
  set_has_start();
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.start)
}
inline ::std::string* MP_Lambda_Input::mutable_start() {
  set_has_start();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_start() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.start)
  if (!has_start()) {
    return NULL;
  }
  clear_has_start();
  return start_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_start(::std::string* start) {
  if (start != NULL) {
    set_has_start();
  } else {
    clear_has_start();
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.start)
}

// optional string goal = 5;
inline bool MP_Lambda_Input::has_goal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MP_Lambda_Input::set_has_goal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MP_Lambda_Input::clear_has_goal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MP_Lambda_Input::clear_goal() {
  goal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_goal();
}
inline const ::std::string& MP_Lambda_Input::goal() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.goal)
  return goal_.GetNoArena();
}
inline void MP_Lambda_Input::set_goal(const ::std::string& value) {
  set_has_goal();
  goal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.goal)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_goal(::std::string&& value) {
  set_has_goal();
  goal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.goal)
}
#endif
inline void MP_Lambda_Input::set_goal(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_goal();
  goal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.goal)
}
inline void MP_Lambda_Input::set_goal(const char* value, size_t size) {
  set_has_goal();
  goal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.goal)
}
inline ::std::string* MP_Lambda_Input::mutable_goal() {
  set_has_goal();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.goal)
  return goal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_goal() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.goal)
  if (!has_goal()) {
    return NULL;
  }
  clear_has_goal();
  return goal_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_goal(::std::string* goal) {
  if (goal != NULL) {
    set_has_goal();
  } else {
    clear_has_goal();
  }
  goal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), goal);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.goal)
}

// optional string min = 6;
inline bool MP_Lambda_Input::has_min() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MP_Lambda_Input::set_has_min() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MP_Lambda_Input::clear_has_min() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MP_Lambda_Input::clear_min() {
  min_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_min();
}
inline const ::std::string& MP_Lambda_Input::min() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.min)
  return min_.GetNoArena();
}
inline void MP_Lambda_Input::set_min(const ::std::string& value) {
  set_has_min();
  min_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.min)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_min(::std::string&& value) {
  set_has_min();
  min_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.min)
}
#endif
inline void MP_Lambda_Input::set_min(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_min();
  min_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.min)
}
inline void MP_Lambda_Input::set_min(const char* value, size_t size) {
  set_has_min();
  min_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.min)
}
inline ::std::string* MP_Lambda_Input::mutable_min() {
  set_has_min();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.min)
  return min_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_min() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.min)
  if (!has_min()) {
    return NULL;
  }
  clear_has_min();
  return min_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_min(::std::string* min) {
  if (min != NULL) {
    set_has_min();
  } else {
    clear_has_min();
  }
  min_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), min);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.min)
}

// optional string max = 7;
inline bool MP_Lambda_Input::has_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MP_Lambda_Input::set_has_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MP_Lambda_Input::clear_has_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MP_Lambda_Input::clear_max() {
  max_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_max();
}
inline const ::std::string& MP_Lambda_Input::max() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.max)
  return max_.GetNoArena();
}
inline void MP_Lambda_Input::set_max(const ::std::string& value) {
  set_has_max();
  max_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.max)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_max(::std::string&& value) {
  set_has_max();
  max_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.max)
}
#endif
inline void MP_Lambda_Input::set_max(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_max();
  max_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.max)
}
inline void MP_Lambda_Input::set_max(const char* value, size_t size) {
  set_has_max();
  max_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.max)
}
inline ::std::string* MP_Lambda_Input::mutable_max() {
  set_has_max();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.max)
  return max_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_max() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.max)
  if (!has_max()) {
    return NULL;
  }
  clear_has_max();
  return max_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_max(::std::string* max) {
  if (max != NULL) {
    set_has_max();
  } else {
    clear_has_max();
  }
  max_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), max);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.max)
}

// optional string robot = 8;
inline bool MP_Lambda_Input::has_robot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MP_Lambda_Input::set_has_robot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MP_Lambda_Input::clear_has_robot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MP_Lambda_Input::clear_robot() {
  robot_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_robot();
}
inline const ::std::string& MP_Lambda_Input::robot() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.robot)
  return robot_.GetNoArena();
}
inline void MP_Lambda_Input::set_robot(const ::std::string& value) {
  set_has_robot();
  robot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.robot)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_robot(::std::string&& value) {
  set_has_robot();
  robot_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.robot)
}
#endif
inline void MP_Lambda_Input::set_robot(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_robot();
  robot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.robot)
}
inline void MP_Lambda_Input::set_robot(const char* value, size_t size) {
  set_has_robot();
  robot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.robot)
}
inline ::std::string* MP_Lambda_Input::mutable_robot() {
  set_has_robot();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.robot)
  return robot_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_robot() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.robot)
  if (!has_robot()) {
    return NULL;
  }
  clear_has_robot();
  return robot_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_robot(::std::string* robot) {
  if (robot != NULL) {
    set_has_robot();
  } else {
    clear_has_robot();
  }
  robot_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), robot);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.robot)
}

// optional string time_limit = 9;
inline bool MP_Lambda_Input::has_time_limit() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MP_Lambda_Input::set_has_time_limit() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MP_Lambda_Input::clear_has_time_limit() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MP_Lambda_Input::clear_time_limit() {
  time_limit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_time_limit();
}
inline const ::std::string& MP_Lambda_Input::time_limit() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.time_limit)
  return time_limit_.GetNoArena();
}
inline void MP_Lambda_Input::set_time_limit(const ::std::string& value) {
  set_has_time_limit();
  time_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.time_limit)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_time_limit(::std::string&& value) {
  set_has_time_limit();
  time_limit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.time_limit)
}
#endif
inline void MP_Lambda_Input::set_time_limit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_time_limit();
  time_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.time_limit)
}
inline void MP_Lambda_Input::set_time_limit(const char* value, size_t size) {
  set_has_time_limit();
  time_limit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.time_limit)
}
inline ::std::string* MP_Lambda_Input::mutable_time_limit() {
  set_has_time_limit();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.time_limit)
  return time_limit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_time_limit() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.time_limit)
  if (!has_time_limit()) {
    return NULL;
  }
  clear_has_time_limit();
  return time_limit_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_time_limit(::std::string* time_limit) {
  if (time_limit != NULL) {
    set_has_time_limit();
  } else {
    clear_has_time_limit();
  }
  time_limit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), time_limit);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.time_limit)
}

// optional string env = 10;
inline bool MP_Lambda_Input::has_env() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MP_Lambda_Input::set_has_env() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MP_Lambda_Input::clear_has_env() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MP_Lambda_Input::clear_env() {
  env_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_env();
}
inline const ::std::string& MP_Lambda_Input::env() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.env)
  return env_.GetNoArena();
}
inline void MP_Lambda_Input::set_env(const ::std::string& value) {
  set_has_env();
  env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.env)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_env(::std::string&& value) {
  set_has_env();
  env_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.env)
}
#endif
inline void MP_Lambda_Input::set_env(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_env();
  env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.env)
}
inline void MP_Lambda_Input::set_env(const char* value, size_t size) {
  set_has_env();
  env_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.env)
}
inline ::std::string* MP_Lambda_Input::mutable_env() {
  set_has_env();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.env)
  return env_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_env() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.env)
  if (!has_env()) {
    return NULL;
  }
  clear_has_env();
  return env_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_env(::std::string* env) {
  if (env != NULL) {
    set_has_env();
  } else {
    clear_has_env();
  }
  env_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), env);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.env)
}

// optional string check_resolution = 11;
inline bool MP_Lambda_Input::has_check_resolution() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MP_Lambda_Input::set_has_check_resolution() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MP_Lambda_Input::clear_has_check_resolution() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MP_Lambda_Input::clear_check_resolution() {
  check_resolution_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_check_resolution();
}
inline const ::std::string& MP_Lambda_Input::check_resolution() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.check_resolution)
  return check_resolution_.GetNoArena();
}
inline void MP_Lambda_Input::set_check_resolution(const ::std::string& value) {
  set_has_check_resolution();
  check_resolution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.check_resolution)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_check_resolution(::std::string&& value) {
  set_has_check_resolution();
  check_resolution_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.check_resolution)
}
#endif
inline void MP_Lambda_Input::set_check_resolution(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_check_resolution();
  check_resolution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.check_resolution)
}
inline void MP_Lambda_Input::set_check_resolution(const char* value, size_t size) {
  set_has_check_resolution();
  check_resolution_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.check_resolution)
}
inline ::std::string* MP_Lambda_Input::mutable_check_resolution() {
  set_has_check_resolution();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.check_resolution)
  return check_resolution_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_check_resolution() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.check_resolution)
  if (!has_check_resolution()) {
    return NULL;
  }
  clear_has_check_resolution();
  return check_resolution_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_check_resolution(::std::string* check_resolution) {
  if (check_resolution != NULL) {
    set_has_check_resolution();
  } else {
    clear_has_check_resolution();
  }
  check_resolution_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), check_resolution);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.check_resolution)
}

// optional string discretization = 12;
inline bool MP_Lambda_Input::has_discretization() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MP_Lambda_Input::set_has_discretization() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MP_Lambda_Input::clear_has_discretization() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MP_Lambda_Input::clear_discretization() {
  discretization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_discretization();
}
inline const ::std::string& MP_Lambda_Input::discretization() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.discretization)
  return discretization_.GetNoArena();
}
inline void MP_Lambda_Input::set_discretization(const ::std::string& value) {
  set_has_discretization();
  discretization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.discretization)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_discretization(::std::string&& value) {
  set_has_discretization();
  discretization_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.discretization)
}
#endif
inline void MP_Lambda_Input::set_discretization(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_discretization();
  discretization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.discretization)
}
inline void MP_Lambda_Input::set_discretization(const char* value, size_t size) {
  set_has_discretization();
  discretization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.discretization)
}
inline ::std::string* MP_Lambda_Input::mutable_discretization() {
  set_has_discretization();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.discretization)
  return discretization_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_discretization() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.discretization)
  if (!has_discretization()) {
    return NULL;
  }
  clear_has_discretization();
  return discretization_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_discretization(::std::string* discretization) {
  if (discretization != NULL) {
    set_has_discretization();
  } else {
    clear_has_discretization();
  }
  discretization_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), discretization);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.discretization)
}

// optional string is_float = 13;
inline bool MP_Lambda_Input::has_is_float() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MP_Lambda_Input::set_has_is_float() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MP_Lambda_Input::clear_has_is_float() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MP_Lambda_Input::clear_is_float() {
  is_float_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_is_float();
}
inline const ::std::string& MP_Lambda_Input::is_float() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.is_float)
  return is_float_.GetNoArena();
}
inline void MP_Lambda_Input::set_is_float(const ::std::string& value) {
  set_has_is_float();
  is_float_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.is_float)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_is_float(::std::string&& value) {
  set_has_is_float();
  is_float_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.is_float)
}
#endif
inline void MP_Lambda_Input::set_is_float(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_is_float();
  is_float_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.is_float)
}
inline void MP_Lambda_Input::set_is_float(const char* value, size_t size) {
  set_has_is_float();
  is_float_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.is_float)
}
inline ::std::string* MP_Lambda_Input::mutable_is_float() {
  set_has_is_float();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.is_float)
  return is_float_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_is_float() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.is_float)
  if (!has_is_float()) {
    return NULL;
  }
  clear_has_is_float();
  return is_float_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_is_float(::std::string* is_float) {
  if (is_float != NULL) {
    set_has_is_float();
  } else {
    clear_has_is_float();
  }
  is_float_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), is_float);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.is_float)
}

// optional string problem_id = 14;
inline bool MP_Lambda_Input::has_problem_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MP_Lambda_Input::set_has_problem_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MP_Lambda_Input::clear_has_problem_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MP_Lambda_Input::clear_problem_id() {
  problem_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_problem_id();
}
inline const ::std::string& MP_Lambda_Input::problem_id() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.problem_id)
  return problem_id_.GetNoArena();
}
inline void MP_Lambda_Input::set_problem_id(const ::std::string& value) {
  set_has_problem_id();
  problem_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.problem_id)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_problem_id(::std::string&& value) {
  set_has_problem_id();
  problem_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.problem_id)
}
#endif
inline void MP_Lambda_Input::set_problem_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_problem_id();
  problem_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.problem_id)
}
inline void MP_Lambda_Input::set_problem_id(const char* value, size_t size) {
  set_has_problem_id();
  problem_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.problem_id)
}
inline ::std::string* MP_Lambda_Input::mutable_problem_id() {
  set_has_problem_id();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.problem_id)
  return problem_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_problem_id() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.problem_id)
  if (!has_problem_id()) {
    return NULL;
  }
  clear_has_problem_id();
  return problem_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_problem_id(::std::string* problem_id) {
  if (problem_id != NULL) {
    set_has_problem_id();
  } else {
    clear_has_problem_id();
  }
  problem_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), problem_id);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.problem_id)
}

// optional string goal_radius = 15;
inline bool MP_Lambda_Input::has_goal_radius() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MP_Lambda_Input::set_has_goal_radius() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MP_Lambda_Input::clear_has_goal_radius() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MP_Lambda_Input::clear_goal_radius() {
  goal_radius_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_goal_radius();
}
inline const ::std::string& MP_Lambda_Input::goal_radius() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.goal_radius)
  return goal_radius_.GetNoArena();
}
inline void MP_Lambda_Input::set_goal_radius(const ::std::string& value) {
  set_has_goal_radius();
  goal_radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.goal_radius)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_goal_radius(::std::string&& value) {
  set_has_goal_radius();
  goal_radius_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.goal_radius)
}
#endif
inline void MP_Lambda_Input::set_goal_radius(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_goal_radius();
  goal_radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.goal_radius)
}
inline void MP_Lambda_Input::set_goal_radius(const char* value, size_t size) {
  set_has_goal_radius();
  goal_radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.goal_radius)
}
inline ::std::string* MP_Lambda_Input::mutable_goal_radius() {
  set_has_goal_radius();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.goal_radius)
  return goal_radius_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_goal_radius() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.goal_radius)
  if (!has_goal_radius()) {
    return NULL;
  }
  clear_has_goal_radius();
  return goal_radius_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_goal_radius(::std::string* goal_radius) {
  if (goal_radius != NULL) {
    set_has_goal_radius();
  } else {
    clear_has_goal_radius();
  }
  goal_radius_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), goal_radius);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.goal_radius)
}

// optional string env_frame = 16;
inline bool MP_Lambda_Input::has_env_frame() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MP_Lambda_Input::set_has_env_frame() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MP_Lambda_Input::clear_has_env_frame() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MP_Lambda_Input::clear_env_frame() {
  env_frame_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_env_frame();
}
inline const ::std::string& MP_Lambda_Input::env_frame() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.env_frame)
  return env_frame_.GetNoArena();
}
inline void MP_Lambda_Input::set_env_frame(const ::std::string& value) {
  set_has_env_frame();
  env_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.env_frame)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_env_frame(::std::string&& value) {
  set_has_env_frame();
  env_frame_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.env_frame)
}
#endif
inline void MP_Lambda_Input::set_env_frame(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_env_frame();
  env_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.env_frame)
}
inline void MP_Lambda_Input::set_env_frame(const char* value, size_t size) {
  set_has_env_frame();
  env_frame_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.env_frame)
}
inline ::std::string* MP_Lambda_Input::mutable_env_frame() {
  set_has_env_frame();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.env_frame)
  return env_frame_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_env_frame() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.env_frame)
  if (!has_env_frame()) {
    return NULL;
  }
  clear_has_env_frame();
  return env_frame_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_env_frame(::std::string* env_frame) {
  if (env_frame != NULL) {
    set_has_env_frame();
  } else {
    clear_has_env_frame();
  }
  env_frame_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), env_frame);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.env_frame)
}

// optional string jobs = 17;
inline bool MP_Lambda_Input::has_jobs() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MP_Lambda_Input::set_has_jobs() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MP_Lambda_Input::clear_has_jobs() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MP_Lambda_Input::clear_jobs() {
  jobs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jobs();
}
inline const ::std::string& MP_Lambda_Input::jobs() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.jobs)
  return jobs_.GetNoArena();
}
inline void MP_Lambda_Input::set_jobs(const ::std::string& value) {
  set_has_jobs();
  jobs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.jobs)
}
#if LANG_CXX11
inline void MP_Lambda_Input::set_jobs(::std::string&& value) {
  set_has_jobs();
  jobs_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.MP_Lambda_Input.jobs)
}
#endif
inline void MP_Lambda_Input::set_jobs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jobs();
  jobs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.MP_Lambda_Input.jobs)
}
inline void MP_Lambda_Input::set_jobs(const char* value, size_t size) {
  set_has_jobs();
  jobs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.MP_Lambda_Input.jobs)
}
inline ::std::string* MP_Lambda_Input::mutable_jobs() {
  set_has_jobs();
  // @@protoc_insertion_point(field_mutable:hello_world.MP_Lambda_Input.jobs)
  return jobs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MP_Lambda_Input::release_jobs() {
  // @@protoc_insertion_point(field_release:hello_world.MP_Lambda_Input.jobs)
  if (!has_jobs()) {
    return NULL;
  }
  clear_has_jobs();
  return jobs_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MP_Lambda_Input::set_allocated_jobs(::std::string* jobs) {
  if (jobs != NULL) {
    set_has_jobs();
  } else {
    clear_has_jobs();
  }
  jobs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jobs);
  // @@protoc_insertion_point(field_set_allocated:hello_world.MP_Lambda_Input.jobs)
}

// optional int64 time_start = 18;
inline bool MP_Lambda_Input::has_time_start() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MP_Lambda_Input::set_has_time_start() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MP_Lambda_Input::clear_has_time_start() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MP_Lambda_Input::clear_time_start() {
  time_start_ = GOOGLE_LONGLONG(0);
  clear_has_time_start();
}
inline ::google::protobuf::int64 MP_Lambda_Input::time_start() const {
  // @@protoc_insertion_point(field_get:hello_world.MP_Lambda_Input.time_start)
  return time_start_;
}
inline void MP_Lambda_Input::set_time_start(::google::protobuf::int64 value) {
  set_has_time_start();
  time_start_ = value;
  // @@protoc_insertion_point(field_set:hello_world.MP_Lambda_Input.time_start)
}

// -------------------------------------------------------------------

// CoordinatorParam

// optional int64 circ_buffer = 1;
inline bool CoordinatorParam::has_circ_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoordinatorParam::set_has_circ_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoordinatorParam::clear_has_circ_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoordinatorParam::clear_circ_buffer() {
  circ_buffer_ = GOOGLE_LONGLONG(0);
  clear_has_circ_buffer();
}
inline ::google::protobuf::int64 CoordinatorParam::circ_buffer() const {
  // @@protoc_insertion_point(field_get:hello_world.CoordinatorParam.circ_buffer)
  return circ_buffer_;
}
inline void CoordinatorParam::set_circ_buffer(::google::protobuf::int64 value) {
  set_has_circ_buffer();
  circ_buffer_ = value;
  // @@protoc_insertion_point(field_set:hello_world.CoordinatorParam.circ_buffer)
}

// -------------------------------------------------------------------

// ActorParam

// optional int64 is_actor = 1;
inline bool ActorParam::has_is_actor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorParam::set_has_is_actor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorParam::clear_has_is_actor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorParam::clear_is_actor() {
  is_actor_ = GOOGLE_LONGLONG(0);
  clear_has_is_actor();
}
inline ::google::protobuf::int64 ActorParam::is_actor() const {
  // @@protoc_insertion_point(field_get:hello_world.ActorParam.is_actor)
  return is_actor_;
}
inline void ActorParam::set_is_actor(::google::protobuf::int64 value) {
  set_has_is_actor();
  is_actor_ = value;
  // @@protoc_insertion_point(field_set:hello_world.ActorParam.is_actor)
}

// -------------------------------------------------------------------

// CryptoParam

// optional bytes key = 3;
inline bool CryptoParam::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CryptoParam::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CryptoParam::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CryptoParam::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& CryptoParam::key() const {
  // @@protoc_insertion_point(field_get:hello_world.CryptoParam.key)
  return key_.GetNoArena();
}
inline void CryptoParam::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hello_world.CryptoParam.key)
}
#if LANG_CXX11
inline void CryptoParam::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hello_world.CryptoParam.key)
}
#endif
inline void CryptoParam::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hello_world.CryptoParam.key)
}
inline void CryptoParam::set_key(const void* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hello_world.CryptoParam.key)
}
inline ::std::string* CryptoParam::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:hello_world.CryptoParam.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CryptoParam::release_key() {
  // @@protoc_insertion_point(field_release:hello_world.CryptoParam.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptoParam::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:hello_world.CryptoParam.key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hello_world

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_hello_2eproto
